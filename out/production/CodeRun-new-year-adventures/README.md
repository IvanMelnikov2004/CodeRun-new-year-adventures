# CodeRun-new-year-adventures

## Решение задач новогодней подборки CodeRun

Разобрано : 5 из 10 задач

## Задача "Ча-ча_ча"

На прошлый Новый год Кодеруну подарили абонемент в школу латиноамериканских танцев. Занятия в школе оцениваются так: каждая оценка записывается одной буквой от «‎A»‎ до «‎Z»‎, где «‎Z»‎ — так себе танцор, а «‎A»‎ — легенда Карибов.

В течение полугода Кодерун получал разные оценки. Теперь ему стало интересно, а какая же итоговая оценка за полгода занятий танцами у него получится? Для подсчёта итоговой оценки берётся среднее арифметическое всех оценок, которые Кодерун получил за шесть месяцев, и округляется в пользу ученика по стандартным правилам округления. Но есть одна неприятная для нашего танцора особенность — нельзя получить оценку, которая более чем на балл выше худшей оценки за полгода.

Помогите Кодеруну посчитать итоговую оценку за полгода занятий.

### Формат ввода
Единственная строка входных данных содержит строку
s, состоящую из заглавных букв латинского алфавита. Гарантируется, что длина строки не превышает 100.

### Формат вывода
Выведите итоговую оценку Кодеруна за полгода.

### Ограничения
Ограничение времени 1 с

Ограничение памяти 256 МБ

**Пример 1**

Ввод

ABACABA

Вывод

B


**Пример 2**

Ввод

AZAA

Вывод

Y

**Пример 3**

Ввод

ABABAB


Вывод

A


## Решение
Для удобста подсчета среднего значения отобразим множество A (оценок) в множество B (Их числовые представления).
Каждой оценке однозначно сопоставляется ее числовое представление. В свою очередь и обратное отображение тоже является однозначным.
Между множествами взаимооднозначное соответстие. 
Заполним словарь translateFrom для отображения A в B и словарь translateTO для отображения B в A.
Согласно условию задачи нужно посчитать среднее арифметическое оценок и учесть худшую оценку.
Посчитаем сумму численных представлений оценок и поделим на количество оценок, чтобы получить среднее арифметическое.
Округлим согласно стандартным правилам округления и вычислим ответ как максимум от средней и худшей оценки.


```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.HashMap;
import java.util.Map;

public class ChaChaCha {
    public static char solve(String str){

        
        
        Map<Character, Integer> translateFrom = new HashMap<>();
        Map<Integer, Character> translateTo = new HashMap<>();
        char x = 'A';
        int z = 28;
        int n = 0;
        float s = 0;
        char bad = 'A';
        while (x <= 'Z'){
            translateFrom.put(x, z);
            translateTo.put(z--, x++);
        }
        for (char cur : str.toCharArray()){
            bad = (char) Math.max(bad, cur);
            s += translateFrom.get(cur);
            n += 1;
        }
        char mid = translateTo.get(Math.round(s / n));
        return (char)(Math.max(bad - 1, mid));
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
        String str = reader.readLine();
        writer.write(solve(str));
        reader.close();
        writer.close();
    }

}


```


## Задача "Нарядаем ёлку"

Новый год на носу, и Кодерун решил нарядить ёлку, но не простую, а геометрическую.

Он знает, что ёлка состоит из
k слоёв, каждый из которых, в свою очередь, состоит из 2^(i−1)
треугольных веточек. На каждую веточку он хочет повесить по шарику. Узнайте, сколько шариков понадобится Кодеруну для того, чтобы украсить всю ёлку.

### Формат ввода
На вход программе подаётся одно натуральное число k (1 ≤ k ≤ 25)− количество слоёв ёлки.
### Формат вывода
В качестве ответа выведите одно число - количество шариков, необходимых для украшения ёлки.

### Ограничения
Ограничение времени 1 с

Ограничение памяти 64 МБ

**Пример 1**

Ввод

3

Вывод

7


**Пример 2**

Ввод

21

Вывод

2097151

**Пример 3**

Ввод

22


Вывод

4194303

## Решение
Требуется найти сумму 2^0 + 2^1 + ... 2^(k - 1)
Эта сумма является позиционной нотацией с основанием 2.
Если каждая степень двойки присутствует в этой сумме, значит двоичное представление результата состоит из 
k - 1 подряд идущих единиц. Это число можно получить как 2^k - 1.

Пример для k = 5:

2^0+2^1+2^2+2^3+2^4 в десятичной =11111 в двоичной = 100000 - 1 в двоичной

```Java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class DecorateChristmasTree {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
        int k = Integer.parseInt(reader.readLine().split(" ")[0]);
        writer.write(""+((1 << k) - 1));
        reader.close();
        writer.close();
    }

}
```

## Задача "Открытка с уравнением"

Кодерун нашёл под ёлкой первый подарок и распаковал его. Внутри был учебник по теории чисел и новогодняя открытка с предложением решить это уравнение:x+p(x)=n , где n — заданное натуральное число, а p(x) обозначает количество различных простых делителей числа x. Например, p(1)=0,p(4)=1,p(12)=2,p(30)=3. Помогите ему найти количество целочисленных положительных решений этого уравнения, то есть количество целых  x>0, для которых верно равенство. Простым называется число, у которого ровно
2 различных делителя. Простые делители числа
x — делители
x, которые являются простыми числам

### Формат ввода
Вам дано число 1≤n≤10^12.
### Формат вывода
Выведите количество положительных целых решений уравнения.

### Ограничения
Ограничение времени 4 с

Ограничение памяти 256 МБ

**Пример 1**

Ввод

12

Вывод

2


**Пример 2**

Ввод

2

Вывод

0

**Пример 3**

Ввод

3


Вывод

1

## Решение
Рассмотрим p(x) - кол-во простых множетелей числа.
Если p(x) = 20, то минимальный x, удовлетворяющий требованию будет 2 * 3 * 5 * 7 * 11 ... (берем минимальные простые числа) и еще 15 множетелей точно больших чем 10.
Тогда минимальных x для которого p(x) = 20 точно больше 10^15, что больше максимального возможного x согласно формату ввода.

Из того, что p(x) = n - x и p(x) < 20 следует, что n - x < 20. Тогда x > n - 20 и мы получили нижнее ограничение множества решений.

Предположим, что p(x) = 0, тогда n = x и это верхнее ограничение на x.

Тогда решения будут лежат в интервале [n - 20; n].

Учитывая, что x - целое число, достаточное перебрать числа из интервала.

Для каждого числа в интервале определим p(x) и проверим подходит ли оно. Посчитаем через решето Эратосфена простые числа до 10^6 (корень от 10^12 - верхнего ограничения на n). 
Потом будем перебирать простые числа и делить x на них пока текущее простое число не превысит корень из x. 

Таким образом для каждого числа x из интервала [n - 20; n] нашли p(x) и проверили какое n образует x + p(x).

```Java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.*;

public class Main {

    //Посчитаем простые числа решетом Эратосфена
    public static List<Long> getPrimesUpTo(int limit) {
        boolean[] isPrime = new boolean[limit + 1];
        for (int i = 2; i <= limit; i++) {
            isPrime[i] = true;
        }

        for (int i = 2; i * i <= limit; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= limit; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        List<Long> primes = new ArrayList<>();
        for (int i = 2; i <= limit; i++) {
            if (isPrime[i]) {
                primes.add((long) i);
            }
        }
        return primes;
    }
    
    //Для числа x определим p(x)
    public static int countDistinctPrimeFactors(long x, List<Long> primes) {
        int count = 0;
        for (long prime : primes) {
            if (prime * prime > x) break;
            if (x % prime == 0) {
                count++;
                while (x % prime == 0) {
                    x /= prime;
                }
            }
        }
        if (x > 1) count++;
        return count;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

        long n = Long.parseLong(reader.readLine().trim());
        int res = 0;
        
        //Массив простых чисел
        List<Long> primes = getPrimesUpTo(1_000_000);

        //Перебираем 100 чисел перед n включая n. Если 100 чисел не наберется, то перебираем от 1 до n
        for (long x = Math.max(1, n - 100); x <= n; x++) {
            //Для x находим p(x)
            int p_x = countDistinctPrimeFactors(x, primes);
            //Проверяем удовлетворяет ли x условию.
            if (x + p_x == n) {
                res++;
            }
        }

        writer.write(String.valueOf(res));
        reader.close();
        writer.close();
    }
}
```

## Задача "В город на ярмарку"

Друзья пригласили Кодеруна к себе в город на новогоднюю ярмарку. Выйдя из поезда, он решил изучить схему местного транспорта. В городе есть
n остановок и m маршрутов, каждый из которых обозначает, что существуют автобусы, которые ходят по заданному маршруту от одной остановки к другой и обратно, при этом не останавливаясь нигде на промежуточных пунктах.

Кодерун задался: интересно, какое максимально возможное количество маршрутов можно убрать? Но так, чтобы выполнялось следующее условие: для любой пары остановок
a, b, если можно было добраться от a до b, используя один или несколько исходных маршрутов, то и после удаления маршрутов можно добраться от a до b.

### Формат ввода
В первой строке содержится количество остановок 1≤n≤100 и 0≤m≤ n∗(n−1)/2. В следующих n строках содержатся описания маршрутов, в каждой строке содержатся по два числа

1≤a[i],b[i]≤n, а[i] != b[i] обозначающие, что существуют автобусы, которые ходят от остановки а[i], к остановке b[i], и от остановки b[i] к a[i].
Гарантируется, что все маршруты различны.
### Формат вывода
Выведите максимально возможное количество маршрутов, которое можно удалить, так, что достижимость между каждой парой остановок останется прежней(если из одной остановки можно было добраться до другой до удаления, то можно из этой остановки добраться до той и после удаления).

### Ограничения
Ограничение времени 2 с

Ограничение памяти 256 МБ

**Пример 1**

Ввод

6 5 \
1 2 \
2 3 \
3 1 \
4 5 \
5 6

Вывод

1


**Пример 2**

Ввод

1 0

Вывод

0


## Решение
Имеем несвязный неориентированный ацикличный граф. Требуется найти кол-во ребер, которые можно убрать, не нарушая исходную связность. 
Решим обратную задачу. Найдем остовное дерево из минимального кол-ва ребер и из этого получим результат. 
Каждая компонента в графе связная по определению. Рассмотрим каждую компоненту по отдельности.
В связном графе остовное дерево с минимальным кол-вом ребер будет всегда содержать n - 1 ребро, где n - кол-во вершин в нем.
Значит и в каждой компоненте с n вершинами будет n - 1 необходимое для связности ребро.
Для решения разобьем граф на компоненты, в каждой найдем кол-во вершин, а значит и кол-во ребер, которые нужны в каждой компоненте для связности.
Сложим результаты каждой отдельной компоненты и вычтем эту сумму из кол-ва исходных ребер.

```Java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] line = reader.readLine().split(" ");
        int n = Integer.parseInt(line[0]);
        int m = Integer.parseInt(line[1]);
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++){
            graph.add(new ArrayList<>());
        }
        boolean[] visited = new boolean[n];
        //Представим граф в виде списка смежности
        for (int i = 0; i < m; i++){
            line = reader.readLine().split(" ");
            int from = Integer.parseInt(line[0]);
            int to = Integer.parseInt(line[1]);
            graph.get(from - 1).add(to - 1);
            graph.get(to - 1).add(from - 1);
        }

        int optimal = 0;
        //Перебираем все ноды
        for (int i = 0; i < n; i++){
            List<Integer> stack = new ArrayList<>();
            int currentNumbersOfNodes = 0;
            stack.add(i);
            //итеративный обход от текущей ноды
            while (!stack.isEmpty()){
                
                int curNode = stack.get(stack.size() - 1);
                if (!visited[curNode]){
                    //Считаем кол-во нод в компоненте
                    currentNumbersOfNodes += 1;
                    //помечаем посещенные ноды, чтобы не попадать в них при следующем переборе и текущем обходе
                    visited[curNode] = true;
                }
                stack.remove(stack.size() - 1);
                if (!graph.get(curNode).isEmpty()){
                    //переход к следующей вершине
                    for (int nextNode : graph.get(curNode)){
                        
                        if (!visited[nextNode]){
                            stack.add(nextNode);
                            currentNumbersOfNodes += 1;
                            visited[nextNode] = true;
                        }
                    }
                }

            }
            optimal += currentNumbersOfNodes != 0 ? currentNumbersOfNodes - 1 : 0;
        }
        writer.write(m - optimal + "");
        reader.close();
        writer.close();

    }
}
```


## Задача "Снежки"

Новогодним утром Кодерун с другом лепили снежки и придумали игру. Изначально у игроков есть три кучки снежков. За свой ход игрок может взять из одной какой-то кучки один или два снежка, при условии, что в кучке есть необходимое количество снежков, и отложить их в сторону. Взятые снежки в дальнейшем не рассматриваются.

Проигрывает игрок, который не может сделать ход.

По заданным размерам трёх кучек определите, кто выиграет при оптимальной игре обоих игроков — тот, кто ходил первым, или тот, кто ходил вторым? Вам нужно ответить на t независимых запросов. Для каждого из них выведите
1, если при данных размерах кучек выигрывает первый игрок, и 0, если первый игрок проигрывает. Ответы на запросы выводите в том порядке, в котором они идут во входных данных.
### Формат ввода
В первой строке входного файла содержится число 1≤t≤10 - число запросов. В следующих t строках содержатся сами запросы.

Каждый запрос описывается тремя числами 0≤a1≤10^9, 0≤a2≤10^9, 0≤a3≤10^9 - размерами кучек.
### Формат вывода
Для каждого запроса выведите 1, если первый игрок при данных размерах кучек выигрывает, и 0 иначе.
### Ограничения
Ограничение времени 2 с

Ограничение памяти 256 МБ

**Пример 1**

Ввод

2 \
1 3 5\
0 0 3

Вывод

1 \
0


## Решение
Рассмотрим решение задачи для 0<=a1, a2, a3 <= 2. Решим ее при помощи стандартного приема решения задач на теорию игр.

0 0 0 - проигрышная позиция. Заполним другие позиции при помощи динамического программирования. Если из текущей позиции можно попать хотя бы в одну проигрышную, то позиция выигрышная, иначе проигрышная.
После этого имеем решения для 0<=a1, a2, a3 <= 2.

В общем же случае к a1, a2, a3 прибавляется произвольное количество троек. К примеру a можно представить в виде x * 3 + k. Тогда для набора (k1, k2, k3) мы уже расчитали выигрыш.  

Для одной кучки справедливо что в позиции x * 3 + k и k выигрывает один и тот же игрок.  
Доказать можно через индукцию  
Базис, что при x = 0 имеем кучу k.  
Переход: для a' = (x + 1) * 3 + k = 3 * x + 3 + k = a + 3. т.е надо доказать, что позиции a и a + 3 равны.  
Поведение одной кучи повторяется каждые 3 единицы из-за ходов 1 и 2.  
Если позиция a проигрышная, то a + 1 и a + 2 выигрышные, а значит из a + 3 нельзя попасть в проигрышную и она сама является проигрышной.  
Это доказывает, что если a проигрышная, то и a + 3 тоже.  
Докажем выигрыш. Если a выигрышная, то либо a - 1, либо a + 1 проигрышный, потому что 3 выигрыша подряд идти не может.  
Если a - 1 проигрышный, то и a - 1 + 3 = a + 2 проигрышный из за цикличности, доказанной выше.  
Тогда имеем либо a + 1, либо a + 2 проигрышный и из a + 3 можно привести позицию в одну из них, а значит a + 3 тоже выигрышная.  
Доказали, что a = a + 3 по позиции.
Тогда для трех куч все аналогично. Можно в произвольном порядке сокращать такие тройки в разных кучах и при корректной игре свести все к предпосчитанным остаткам (k1, k2, k3).
Из этого следует, что если ситуация (k1, k2, k3) выигрышная, то и (b1 * 3 + k1, b2 * 3 + k2, b3 * 3 + k3) выигрышная.
Тогда возьмем по модулю 3 вводные a1, a2, a3 и получим решение из предпосчитанных динамикой решений на малых входных данных.

```Java
import java.io.*;
import java.util.*;

public class Main {

    static Map<String, String> mp = new HashMap<>();
    
    //Проверка на проигрышность (a, b, c)
    public static boolean check(int a, int b, int c){
        if (a < 0 || b < 0 || c < 0){
            return false;
        }
        return mp.getOrDefault((a + "_" + b + "_" + c), "z").equals("0");
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
        int t = Integer.parseInt(reader.readLine());

        //инициализируем пустые кучи.
        mp.put("0_0_0", "0");
        for (int i = 0; i < 3; i++){
            for (int j = 0; j < 3; j++){
                for (int g = 0; g < 3; g++){
                    if (i == 0 && j == 0 && g == 0) continue;
                    if (check(i - 1, j, g) || check(i - 2, j, g) || check(i, j - 1, g) || check(i, j - 2, g) || check(i, j, g - 1) || check(i, j, g - 2)){
                        mp.put(i +"_"+ j +"_"+ g, "1");
                    }
                    else{
                        mp.put(i +"_"+ j +"_"+ g, "0");
                    }
                }
            }
        }
        for (int i = 0; i < t; i++){
            String[] line = reader.readLine().split(" ");
            line[0] = Integer.toString((Integer.parseInt(line[0]) % 3));
            line[1] = Integer.toString((Integer.parseInt(line[1]) % 3));
            line[2] = Integer.toString((Integer.parseInt(line[2]) % 3));
            writer.write(mp.get(line[0]+"_"+line[1]+"_"+line[2]) + "\n");
        }

        reader.close();
        writer.close();

    }
}
```







## Задачи "Мандарины и апельсины 1.0 и 2.0"

Кодерун решил собрать всю свою большую семью и устроить просмотр любимого кино. По новогодней традиции в семье Кодеруна фильмы смотрят только с чаем и мандариновым тирамису. Пора его приготовить!

В 2n−1 ящиках лежат мандарины и апельсины. Кодерун хочет выбрать
n ящиков так, чтобы в них оказалось не менее половины всех мандаринов и не менее половины всех апельсинов. Помогите Кодеруну понять, можно ли так выбрать коробки, чтобы это условие выполнялось?

### Формат ввода
В первой строке входных данных записано число n (1≤n≤10^5) - количество ящиков с фруктами.

Далее следует 2⋅n−1 строк, в каждой из которых записано 2 числа, разделённых пробелом:
m[i] и o[i] (1≤m[i],o[i] ≤10^9) - кол-во мандаринов и апельсинов в коробке с номером i
### Формат вывода
В качестве ответа выведите Yes
−
− если выбрать коробки таким образом можно, No в противном случае.

### Ограничения
Ограничение времени 1 с

Ограничение памяти 64 МБ

**Пример 1**

Ввод

4  
5 5  
4 2  
4 4  
5 5  
3 2  
2 4  
1 5

Вывод

Yes


**Пример 2**

Ввод

2  
3 5  
1 2  
1 5  

Вывод

Yes

**Пример 3**

Ввод

3  
5 5  
2 4  
3 3  
3 5  
4 1


Вывод

Yes


## Решение


```java
//Тут будет решение

```